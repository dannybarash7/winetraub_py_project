# -*- coding: utf-8 -*-
"""run_oct2hist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/WinetraubLab/OCT2Hist-ModelInference/blob/main/run_oct2hist.ipynb

# Overview
Use this notebook to convert an OCT image to virtual histology.

To get started,
[open this notebook in colab](https://colab.research.google.com/github/WinetraubLab/OCT2Hist-ModelInference/blob/main/run_oct2hist.ipynb) and run.
"""
import sys

import numpy as np
import requests
import torch
from segment_anything import sam_model_registry, SamPredictor
from tqdm import tqdm

from zero_shot_segmentation.zero_shot_utils.predict_mask_on_oct import predict

# from google.colab import drive
sys.path.append('./zero_shot_segmentation')
import cv2

sys.path.append('./OCT2Hist_UseModel')
import os

# Define the Roboflow project URL and API key
api_key="R04BinsZcBZ6PsfKR2fP"
workspace="yolab-kmmfx"
project_name = "draft-zero-shot-oct"
dataset_type = "png-mask-semantic"
#roboflow semantic classes
DERMIS = 1
EPIDERMIS = 2

# Function to download images and masks from Roboflow
def download_images_and_masks(api_key, workspace, project_name, dataset_name):
    from roboflow import Roboflow
    rf = Roboflow(api_key=api_key)
    project = rf.workspace(workspace).project(project_name)
    dataset = project.version(2).download(dataset_type)
    return dataset


# Function to calculate Intersection over Union (IoU)
def calculate_iou(mask_true, mask_pred, class_id):
    intersection = np.logical_and(mask_true == class_id, mask_pred == class_id)
    union = np.logical_or(mask_true == class_id, mask_pred == class_id)

    class_iou = np.sum(intersection) / np.sum(union)
    return class_iou


# Download images and masks
dataset = download_images_and_masks(api_key, workspace, project_name, dataset_type)
# prepare model
DEVICE = torch.device('mps')  # 'cpu'
MODEL_TYPE = "vit_h"
CHECKPOINT_PATH = "/Users/dannybarash/Code/oct/zero_shot_segmentation_test_sam/weights/sam_vit_h_4b8939.pth"  # os.path.join("weights", "sam_vit_h_4b8939.pth")
sam = sam_model_registry[MODEL_TYPE](checkpoint=CHECKPOINT_PATH).to(device=DEVICE)
predictor = SamPredictor(sam)


total_iou = 0
total_samples = 0
dataset_dir = "/Users/dannybarash/Code/oct/zero_shot_segmentation_test_sam/zero_shot_segmentation/draft-zero-shot-oct-2/test/"
# Get the list of image files
image_files = [f for f in os.listdir(dataset_dir) if f.endswith(".jpg")]

total_iou = {0: 0, 1: 0, 2: 0, 3: 0}  # IOU for each class
total_samples = 0

for image_file in tqdm(image_files):
    image_path = os.path.join(dataset_dir, image_file)
    mask_path = os.path.join(dataset_dir, image_file.replace(".jpg", "_mask.png"))

    mask_true = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)

    # Predict the mask using your model
    masks, masked_gel_image = predict(image_path, predictor)
    if masks is None:
        print(f"Could not segment {image_path}.")
        continue
    mask_pred = np.zeros_like(masks[0], dtype=np.float32)
    #switch to semantic_segmentation format
    masked_gel_image = masked_gel_image[:,:,0]
    mask_pred[masked_gel_image > 0] = DERMIS
    mask_pred[masks[0]] = EPIDERMIS
    mask_pred = cv2.resize(mask_pred, (mask_true.shape[1], mask_true.shape[0]), interpolation =  cv2.INTER_NEAREST)


    # Calculate IoU for each class
    for class_id in [DERMIS, EPIDERMIS]:
        class_iou = calculate_iou(mask_true, mask_pred, class_id)
        total_iou[class_id] += class_iou

    total_samples += 1
sum_iou_all_classes = 0
for k in [DERMIS, EPIDERMIS]:
    avg_iou_class = total_iou[k]/total_samples
    sum_iou_all_classes += total_iou[k]
    print(f"iou for {k}:{avg_iou_class}")
    # Calculate the average IoU
average_iou = sum_iou_all_classes / (total_samples * len(total_iou)) #sum all ious divided by (number of images * number of classes).
print(f"Average IoU: {average_iou}")
